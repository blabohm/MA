cityBound <- select(cityBound, code = matches(code_string)) %>%
st_transform(crs)
is.null(city_code)
cityBound
buffer_dist = 0
cityBound %>%
filter(substr(code, 1, 5) %in% city_code) %>%
st_buffer(buffer_dist)
cityBoundLoader <- function(city_boundaries, city_code = NULL, buffer_dist = 0,
code_string = "FUA_CO", crs = 3035)
{
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
if (class(city_boundaries) == "character")  {
cityBound <- st_read(city_boundaries, quiet = TRUE) } else {
cityBound <- city_boundaries }
# User communication
message("Load city boundary")
cityBound <- select(cityBound, code = matches(code_string)) %>%
st_transform(crs)
if (is.null(city_code)) return(cityBound) else {
cityBound %>%
filter(substr(code, 1, 5) %in% city_code) %>%
st_buffer(buffer_dist) %>%
return() }
}
city_boundary
# Load city boundary
cityBound <- cityBoundLoader(city_boundaries = city_boundary, city_code = city_code,
code_string = "URAU_CO")
cityBoundLoader <- function(city_boundaries, city_code = NULL, buffer_dist = 0,
code_string = "FUA_CO", crs = 3035)
{
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
if (class(city_boundaries) == "character")  {
cityBound <- st_read(city_boundaries, quiet = TRUE) } else {
cityBound <- city_boundaries }
# User communication
message("Load city boundary")
cityBound <- select(cityBound, code = matches(code_string)) %>%
mutate(code = substr(code, 1, 5)) %>%
st_transform(crs)
if (is.null(city_code)) return(cityBound) else {
cityBound %>%
filter(code %in% city_code) %>%
st_buffer(buffer_dist) %>%
return() }
}
# Load city boundary
cityBound <- cityBoundLoader(city_boundaries = city_boundary, city_code = city_code,
code_string = "URAU_CO")
cityBound
cityBoundLoader <- function(city_boundaries, city_code = NULL, buffer_dist = 0,
code_string = "FUA_CO", crs = 3035)
{
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
if (class(city_boundaries) == "character")  {
cityBound <- st_read(city_boundaries, quiet = TRUE) } else {
cityBound <- city_boundaries }
# User communication
message("Load city boundary")
cityBound <- cityBound %>%
select(code = matches(code_string)) %>%
mutate(code = substring(code, 1, 5)) %>%
st_transform(crs)
if (is.null(city_code)) return(cityBound) else {
cityBound %>%
filter(code %in% city_code) %>%
st_buffer(buffer_dist) %>%
return() }
}
# Load city boundary
cityBound <- cityBoundLoader(city_boundaries = city_boundary, city_code = city_code,
code_string = "URAU_CO")
cityBoundLoader <- function(city_boundaries, city_code = NULL, buffer_dist = 0,
code_string = "FUA_CO", crs = 3035)
{
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
if (class(city_boundaries) == "character")  {
cityBound <- st_read(city_boundaries, quiet = TRUE) } else {
cityBound <- city_boundaries }
# User communication
message("Load city boundary")
cityBound <- cityBound %>%
select(code = matches(code_string)) %>%
mutate(code = substr(cityBound$code, 1, 5)) %>%
st_transform(crs)
if (is.null(city_code)) return(cityBound) else {
cityBound %>%
filter(code %in% city_code) %>%
st_buffer(buffer_dist) %>%
return() }
}
# Load city boundary
cityBound <- cityBoundLoader(city_boundaries = city_boundary, city_code = city_code,
code_string = "URAU_CO")
city_boundary
city_code
# OVERVIEW:
# 1. READ UA 2018 DATA
# 2. READ OSM BUILDING TILE
# 3. FILTER OSM BUILDINGS FOR INSIDE UA RESIDENTIAL POLYGONS
# 4. ADD POPULATION FROM URBAN ATLAS
# 5. ADD BUILDING ID
#
################################################################################
# INPUT VALUES FOR TESTING CODE
# DATA DIRECTORIES FOR UA AND OSM DATA
osm_dir <-  "E:/osm_buildings/"
city_bound <- "E:/citiesEurope/Cities.shp"
ua_dir <- "C:/Berlin/UA2018/"
net_dir <- "C:/Berlin/network_clean.gpkg"
# FUA CITY CODE
cityCode <- "DE001"
outDir <- "C:/Berlin/popTiles/"
city_boundaries = city_boundary
osm_directory = osm_dir
ua_directory = ua_dir
out_dir = outDir
city_code = cityCode
city_boundaries = city_bound
city_boundaries = city_boundary
city_boundary = city_bound
# Load city boundary
cityBound <- cityBoundLoader(city_boundaries = city_boundary, city_code = city_code,
code_string = "URAU_CO")
# LOAD PACKAGES AND FUNCTIONS
require(dplyr, quietly = TRUE)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-2[A-Za-z].*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
# Load city boundary
cityBound <- cityBoundLoader(city_boundaries = city_boundary, city_code = city_code,
code_string = "URAU_CO")
cityBound
# GET DIRECTORIES OF OSM FILES INSIDE UA BOUNDARY
osm_file_list <-
list.files(osm_directory, pattern = city_code, full.names = TRUE) %>%
proximity_checker(city_boundary = cityBound, city_code = city_code,
osm_file = .)
sfc2bb <- function(sfc_object, crs = 3035)
{
require(sf)
require(dplyr)
bb <- st_bbox(sfc_object)
list(rbind(c(bb$xmin, bb$ymin),
c(bb$xmax, bb$ymin),
c(bb$xmax, bb$ymax),
c(bb$xmin, bb$ymax),
c(bb$xmin, bb$ymin))) %>%
sf::st_polygon() %>%
sf::st_sfc() %>%
sf::st_sf(crs = crs) %>%
return()
}
# GET DIRECTORIES OF OSM FILES INSIDE UA BOUNDARY
osm_file_list <-
list.files(osm_directory, pattern = city_code, full.names = TRUE) %>%
proximity_checker(city_boundary = cityBound, city_code = city_code,
osm_file = .)
OSMfilter <- function(osm_buildings, ua_residential, city_boundaries)
{
# required packages
require(dplyr)
require(sf)
# bildings that are not residential
not_res <- c("^mall$", "train_station", "garages", "hospital",
"parking", "sports_centre", "university", "gas_station",
"school", "hall", "government", "prison", "sports_hall",
"carport", "garbage", "waste")
# user communication
message("\n filtering OSM buildings... \n")
# filtering
osm_buildings %>%
st_filter(cityBound, .pred = st_intersects) %>%
st_join(ua_residential) %>%
# filter OSM buildings inside UA residential polygons
filter(!is.na(code_2018)) %>%
# filter OSM buildings with non residential classes
filter(!(building %in% not_res)) %>%
select(Pop2018, identifier, code_2018) %>%
return()
}
osm_file_list
# 1. READ UA 2018 DATA
#    -> FILTER FOR RESIDENTIAL AREAS
UAresidential <- UAresLoader(ua_directory)
out_dir
# 2. READ OSM BUILDING TILE
#    -> CHECK IF OSM LAYER IS INSIDE CITY BOUNDARIES
#    -> UNITE LAYERS IF NECESSARY
for(osm_file in osm_file_list$tile_dir) {
tmpDir <- paste0(out_dir, strsplit(osm_file, "/")[[1]] %>% last())
osm_file %>%
OSMloader() %>%
# 3. FILTER OSM BUILDINGS FOR INSIDE UA RESIDENTIAL POLYGONS
OSMfilter(ua_residential = UAresidential, city_boundaries = cityBound) %>%
# 4. ADD POPULATION FROM URBAN ATLAS
#    -> 1. FROM UA POLYGON
#    -> 2. FROM AVERAGE POP / AREA IN TILE (IF NO POP INFO AT POLYGON)
OSMpop() %>%
# 5. ADD BUILDING ID
#    -> IDENTIFIER + NUMBER
OSMbuildID() %>%
st_write(tmpDir, quiet = TRUE)
}
################################################################################
# OVERVIEW:
# CONVERT TO BUILDING CENTROID
# READ OSM NETWORK
# OUTPUT TO TEMP
################################################################################
net_dir <- "D:/Berlin/network_clean1.gpkg"
gs_dir <- "D:/Berlin/green_space_entries.gpkg"
be_dir <- "D:/Berlin/popTiles/"
tmpDir <- "D:/Berlin/popTilesSnapped/"
# LOAD PACKAGES AND FUNCTIONS
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-4[A-Za-z].*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
# READ OSM NETWORK
OSMnetwork <- st_read(net_dir, quiet = TRUE)
gsEntries <- st_read(gs_dir, quiet = TRUE)
################################################################################
# OVERVIEW:
# CONVERT TO BUILDING CENTROID
# READ OSM NETWORK
# OUTPUT TO TEMP
################################################################################
net_dir <- "E:/Berlin/network_clean1.gpkg"
gs_dir <- "E:/Berlin/green_space_entries.gpkg"
be_dir <- "E:/Berlin/popTiles/"
tmpDir <- "E:/Berlin/popTilesSnapped/"
################################################################################
# OVERVIEW:
# CONVERT TO BUILDING CENTROID
# READ OSM NETWORK
# OUTPUT TO TEMP
################################################################################
net_dir <- "C:/Berlin/network_clean1.gpkg"
gs_dir <- "C:/Berlin/green_space_entries.gpkg"
be_dir <- "C:/Berlin/popTiles/"
tmpDir <- "C:/Berlin/popTilesSnapped/"
# LOAD PACKAGES AND FUNCTIONS
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-4[A-Za-z].*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
# READ OSM NETWORK
OSMnetwork <- st_read(net_dir, quiet = TRUE)
gsEntries <- st_read(gs_dir, quiet = TRUE)
# CONVERT TO BUILDING CENTROID AND SNAP TO NEAREST NETWORK LINES
#    -> POINT ON SURFACE
#    -> SNAP BUILDING CENTROIDS TO NETWORK
# OUTPUT TO TEMP
be_tiles <- list.files(be_dir, pattern = ".gpkg$", full.names = TRUE)
tile <- be_tiles[1]
inTile <- tile %>%
st_read(quiet = TRUE)
bbox <- sfc2bb(inTile) %>%
st_buffer(100)
net_tile <- OSMnetwork %>%
st_filter(bbox, .pred = st_intersects)
points <- inTile
lines <- net_tile
point_data <- st_drop_geometry(points)
#n = nrow(x)
d = st_distance(points, lines)
distToLine <- apply(d, 1, min, na.rm = TRUE)
validPoints <- distToLine <= maxDist
distToPoint <- apply(d, 2, min, na.rm = TRUE)
validLines <- distToPoint <= maxDist
maxDist = 1000
validPoints <- distToLine <= maxDist
distToPoint <- apply(d, 2, min, na.rm = TRUE)
validLines <- distToPoint <= maxDist
points <- points[validPoints, ]
lines <- lines[validLines, ]
d <- d[validPoints, validLines, drop = FALSE]
distToLine <- distToLine[validPoints]
if (!any(validPoints)) message("No points closer than threshold!")
nearest_line_index = apply(d, 1, which.min)
coordsLines = st_geometry(lines)
coordsPoints = st_geometry(points)
coordsLines = st_coordinates(lines)
coordsPoints = st_coordinates(points)
mNewCoords = vapply(1:nrow(points), function(x) nearestPointOnLine(coordsLines[[nearest_line_index[x]]][[1]],
coordsPoints[x, ]), FUN.VALUE = c(0, 0))
coordsLines
nrow(coordsLines)
2:nrow(coordsLines)
nearestPointOnLine <- function(coordsLine, coordsPoint)
{
nearest_points = vapply(2:nrow(coordsLine), function(x) nearestPointOnSegment(coordsLine[(x - 1):x, ],
coordsPoint), FUN.VALUE = c(0, 0, 0))
nearest_points[1:2, which.min(nearest_points[3, ])]
}
nearestPointOnSegment <- function(s, p)
{
ap = c(p[1] - s[1, 1], p[2] - s[1, 2])
ab = c(s[2, 1] - s[1, 1], s[2, 2] - s[1, 2])
t = sum(ap * ab)/sum(ab * ab)
t = ifelse(t < 0, 0, ifelse(t > 1, 1, t))
t = ifelse(is.na(t), 0, t)
x = s[1, 1] + ab[1] * t
y = s[1, 2] + ab[2] * t
result = c(x, y, sqrt((x - p[1])^2 + (y - p[2])^2))
names(result) = c("X", "Y", "distance")
result
}
mNewCoords = vapply(1:nrow(points), function(x) nearestPointOnLine(coordsLines[[nearest_line_index[x]]][[1]],
coordsPoints[x, ]), FUN.VALUE = c(0, 0))
1:nrow(points)
x <- 1
coordsLines[[nearest_line_index[x]]]
coordsLines[nearest_line_index[x]]
coordsLines
nearest_line_index
coordsLines[L1 == nearest_line_index[x]]
coordsLines$L1
coordsLines
coordsLines[,3]
coordsLines[coordsLines[,3] == nearest_line_index[x]]
coordsLines[coordsLines[,3] == nearest_line_index[x],]
coordsPoints[x, ]
mNewCoords = vapply(1:nrow(points),
function(x) nearestPointOnLine(coordsLines[coordsLines[,3] == nearest_line_index[x],][[1]],
coordsPoints[x, ]), FUN.VALUE = c(0, 0))
mNewCoords = vapply(1:nrow(points),
function(x) nearestPointOnLine(coordsLines[coordsLines[,3] == nearest_line_index[x],],
coordsPoints[x, ]), FUN.VALUE = c(0, 0))
mNewCoords
st_as_sf(mNewCoords)
t(mNewCoords)
as_tibble(t(mNewCoords), point_data)
as_tibble(t(mNewCoords)) %>%
st_as_sf()
as_tibble(t(mNewCoords)) %>%
st_as_sfc()
t(mNewCoords) %>%
st_point()
t(mNewCoords) %>%
tibble()
t(mNewCoords) %>%
as_tibble()
t(mNewCoords) %>%
as_tibble() %>%
transmute(geom = st_point())
t(mNewCoords) %>%
as_tibble() %>%
transmute(geom = st_point(X, Y))
t(mNewCoords) %>%
as_tibble() %>%
transmute(geom = st_point(c(X, Y)))
t(mNewCoords) %>%
as_tibble() %>%
st_as_sf(coords = c("X", "Y"), crs = 3035)
t(mNewCoords) %>%
as_tibble() %>%
st_as_sf(coords = c("X", "Y"), crs = 3035) %>%
bind_cols(point_data)
st_snap_points = function(points, lines, maxDist = 1000)
{
point_data <- st_drop_geometry(points)
d = st_distance(points, lines)
distToLine <- apply(d, 1, min, na.rm = TRUE)
validPoints <- distToLine <= maxDist
distToPoint <- apply(d, 2, min, na.rm = TRUE)
validLines <- distToPoint <= maxDist
points <- points[validPoints, ]
lines <- lines[validLines, ]
d <- d[validPoints, validLines, drop = FALSE]
distToLine <- distToLine[validPoints]
if (!any(validPoints)) return(message("No points closer than threshold!"))
nearest_line_index = apply(d, 1, which.min)
coordsLines = st_coordinates(lines)
coordsPoints = st_coordinates(points)
mNewCoords = vapply(1:nrow(points),
function(x) nearestPointOnLine(coordsLines[coordsLines[,3] == nearest_line_index[x],],
coordsPoints[x, ]), FUN.VALUE = c(0, 0))
t(mNewCoords) %>%
as_tibble() %>%
st_as_sf(coords = c("X", "Y"), crs = 3035) %>%
bind_cols(point_data) %>%
return()
}
st_snap_points(inTile, net_tile)
library(ggplot2)
library(ggplot2)
ggplot() +
geom_sf(net_tile)
plot(net_tile)
plot(inTile, add = TRUE)
out <- st_snap_points(inTile, net_tile, max_dist = 200)
out <- st_snap_points(inTile, net_tile, maxDist = 200)
plot(out)
plot(net_tile)
plot(inTile, add = TRUE)
plot(out, add = TRUE)
plot(out$geometry, add = TRUE)
distinct(out$geometry)
distinct(out)
out$population
select(out, geometry) %>%
distinct
st_snap_points1 = function(x, y, max_dist = 1000) {
if (inherits(x, "sf")) n = nrow(x)
if (inherits(x, "sfc")) n = length(x)
out = do.call(c,
lapply(seq(n), function(i) {
nrst = st_nearest_points(st_geometry(x)[i], y)
nrst_len = st_length(nrst)
nrst_mn = which.min(nrst_len)
if (as.vector(nrst_len[nrst_mn]) > max_dist) return(st_geometry(x)[i])
return(st_cast(nrst[nrst_mn], "POINT")[2])
})
)
return(out)
}
out1 <- st_snap_points1(inTile, net_tile)
out1
plot(out1, add = TRUE)
out <- st_snap_points(inTile, net_tile)
plot(net_tile)
plot(inTile, add = TRUE)
plot(out$geometry, add = TRUE, col = "green")
plot(out1, add = TRUE, col = "red")
inTile
inTile <- tile %>%
st_read(quiet = TRUE) %>%
st_point_on_surface()
inTile
out1 <- st_snap_points1(inTile, net_tile)
out <- st_snap_points(inTile, net_tile)
plot(net_tile)
plot(inTile, add = TRUE)
plot(out$geometry, add = TRUE, col = "green")
plot(out1, add = TRUE, col = "red")
plot(out$geometry, add = TRUE, col = "green")
################################################################################
# OVERVIEW:
# CONVERT TO BUILDING CENTROID
# READ OSM NETWORK
# OUTPUT TO TEMP
################################################################################
net_dir <- "C:/Berlin/network_clean1.gpkg"
gs_dir <- "C:/Berlin/green_space_entries.gpkg"
be_dir <- "C:/Berlin/popTiles/"
tmpDir <- "C:/Berlin/popTilesSnapped/"
# LOAD PACKAGES AND FUNCTIONS
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-4[A-Za-z].*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
# READ OSM NETWORK
OSMnetwork <- st_read(net_dir, quiet = TRUE)
gsEntries <- st_read(gs_dir, quiet = TRUE)
# CONVERT TO BUILDING CENTROID AND SNAP TO NEAREST NETWORK LINES
#    -> POINT ON SURFACE
#    -> SNAP BUILDING CENTROIDS TO NETWORK
# OUTPUT TO TEMP
be_tiles <- list.files(be_dir, pattern = ".gpkg$", full.names = TRUE)
be_tiles
tile <- be_tiles[1]
tile
outName <- strsplit(tile, "/") %>% last()
outName
outName <- strsplit(tile, "/")[[1]] %>% last()
outName
tmpDir
rm(tile, outName)
for (tile in be_tiles) {
# string for output generation
outName <- strsplit(tile, "/")[[1]] %>% last()
inTile <- tile %>%
st_read(quiet = TRUE) %>%
st_point_on_surface()
bbox <- sfc2bb(inTile) %>%
st_buffer(100)
net_tile <- OSMnetwork %>%
st_filter(bbox, .pred = st_intersects)
out <- st_snap_points(inTile, net_tile, maxDist = 200)
#snapPTLsf(points_sf = inTile, lines_sf = net_tile, max_distance = 200) %>%
st_write(out, paste0(tmpDir, outName),
quiet = TRUE, append = FALSE) #16:12
}
for (tile in be_tiles) {
# string for output generation
outName <- strsplit(tile, "/")[[1]] %>% last()
inTile <- tile %>%
st_read(quiet = TRUE) %>%
st_point_on_surface()
bbox <- sfc2bb(inTile) %>%
st_buffer(100)
net_tile <- OSMnetwork %>%
st_filter(bbox, .pred = st_intersects)
out <- st_snap_points(inTile, net_tile, maxDist = 200)
#snapPTLsf(points_sf = inTile, lines_sf = net_tile, max_distance = 200) %>%
st_write(out, paste0(tmpDir, outName),
quiet = TRUE, append = FALSE) #16:12
}

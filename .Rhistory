city_code = cityCode,
output = "sf")
greenSpaceEntries <- findGSentries(green_spaces = greenSpaces,
network = netwrk)
}
output <- get_green_space_entries(cityBoundaries, cityCode,
uaDirectory, netwrk)
750 * 9
750 * 9 -> a
b <- 1200 * 9
c <- 500 * 9
d <- 750 * 9
a + c
b + d
11250/7
1600/9
3500/400
11250/8
1400/9
# OVERVIEW:
# 1. READ UA 2018 DATA
# 2. READ OSM BUILDING TILE
# 3. FILTER OSM BUILDINGS FOR INSIDE UA RESIDENTIAL POLYGONS
# 4. ADD POPULATION FROM URBAN ATLAS
# 5. ADD BUILDING ID
#
################################################################################
# INPUT VALUES FOR TESTING CODE
# DATA DIRECTORIES FOR UA AND OSM DATA
osm_dir <-  "E:/osm_buildings/"
ua_dir <- "C:/Berlin/UA2018/"
net_dir <- "C:/Berlin/network_clean.gpkg"
# FUA CITY CODE
cityCode <- "DE001"
outDir <- "C:/Berlin/popTiles/"
# LOAD PACKAGES AND FUNCTIONS
require(dplyr, quietly = TRUE)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-2[A-Za-z].*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
#  GET DIRECTORIES OF OSM FILES INSIDE UA BOUNDARY
osm_file_list <-
list.files(osm_directory, pattern = city_code, full.names = TRUE) %>%
proximity_checker(city_boundary = ua_directory, city_code = city_code,
osm_file = .)
osm_directory = osm_dir
ua_directory = ua_dir
city_code = cityCode
out_dir = outDir
#  GET DIRECTORIES OF OSM FILES INSIDE UA BOUNDARY
osm_file_list <-
list.files(osm_directory, pattern = city_code, full.names = TRUE) %>%
proximity_checker(city_boundary = ua_directory, city_code = city_code,
osm_file = .)
osm_file_list
osm_file <- list.files(osm_dir,
pattern = cityCode, full.names = TRUE) ##file select#############################################
osm_file
city_boundary <- "C:/Berlin/UA2018/DE001/DE001L1_BERLIN_UA2018_v013.gpkg"
a <- osm_file[9]
a
table <- st_layers(a)$name[1]
table
st_layers(a)
st_layers(a)$features
which.max(st_layers(a)$features)
x <- which.max(st_layers(a)$features)
table <- st_layers(a)$name[x]
table
proximity_checker <- function(city_boundary, osm_file, city_code)
{
# Load required packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
# Load city boundary
cb_file <- city_boundary %>%
list.files(pattern = city_code,
full.names = TRUE) %>%
list.files(pattern = "gpkg$",
full.names = TRUE,
recursive = TRUE)
lyr_tbl <- st_layers(cb_file)
x <- which.max(lyr_tbl$features)
lyr <- lyr_tbl$name[x]
cityBound <- st_read(cb_file, lyr, quiet = TRUE) %>%
st_transform(3035)
# User communication
message("Checking proximity")
tmpDf <- tibble()
for (i in osm_file) {
# Filter for desired city
lyr1 <- st_layers(i)$name[1]
c <- st_read(i, layer = lyr1, quiet = TRUE) %>%
st_transform(3035) %>%
sfc2bb()
# Check for proximity of other cities
if(any(st_intersects(c$geom, cityBound, sparse = FALSE)))
tmpDf <- tibble(tile_dir = i) %>%
bind_rows(tmpDf)
}
return(tmpDf)
}
# GET DIRECTORIES OF OSM FILES INSIDE UA BOUNDARY
osm_file_list <-
list.files(osm_directory, pattern = city_code, full.names = TRUE) %>%
proximity_checker(city_boundary = ua_directory, city_code = city_code,
osm_file = .)
sfc2bb <- function(sfc_object, crs)
{
require(sf)
require(dplyr)
bb <- st_bbox(sfc_object)
list(rbind(c(bb$xmin, bb$ymin),
c(bb$xmax, bb$ymin),
c(bb$xmax, bb$ymax),
c(bb$xmin, bb$ymax),
c(bb$xmin, bb$ymin))) %>%
sf::st_polygon() %>%
sf::st_sfc() %>%
sf::st_sf(crs = crs) %>%
return()
}
proximity_checker <- function(city_boundary, osm_file, city_code, crs = 3035)
{
# Load required packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
# Load city boundary
cb_file <- city_boundary %>%
list.files(pattern = city_code,
full.names = TRUE) %>%
list.files(pattern = "gpkg$",
full.names = TRUE,
recursive = TRUE)
lyr_tbl <- st_layers(cb_file)
x <- which.max(lyr_tbl$features)
lyr <- lyr_tbl$name[x]
cityBound <- st_read(cb_file, lyr, quiet = TRUE) %>%
st_transform(crs)
# User communication
message("Checking proximity")
tmpDf <- tibble()
for (i in osm_file) {
# Filter for desired city
lyr1 <- st_layers(i)$name[1]
c <- st_read(i, layer = lyr1, quiet = TRUE) %>%
sfc2bb(crs = crs)
# Check for proximity of other cities
if(any(st_intersects(c$geom, cityBound, sparse = FALSE)))
tmpDf <- tibble(tile_dir = i) %>%
bind_rows(tmpDf)
}
return(tmpDf)
}
# GET DIRECTORIES OF OSM FILES INSIDE UA BOUNDARY
osm_file_list <-
list.files(osm_directory, pattern = city_code, full.names = TRUE) %>%
proximity_checker(city_boundary = ua_directory, city_code = city_code,
osm_file = .)
proximity_checker <- function(city_boundary, osm_file, city_code, crs = 3035)
{
# Load required packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
# Load city boundary
cb_file <- city_boundary %>%
list.files(pattern = city_code,
full.names = TRUE) %>%
list.files(pattern = "gpkg$",
full.names = TRUE,
recursive = TRUE)
lyr_tbl <- st_layers(cb_file)
x <- which.max(lyr_tbl$features)
lyr <- lyr_tbl$name[x]
cityBound <- st_read(cb_file, lyr, quiet = TRUE) %>%
st_transform(crs)
# User communication
message("Checking proximity")
tmpDf <- tibble()
for (i in osm_file) {
# Filter for desired city
lyr1 <- st_layers(i)$name[1]
c <- st_read(i, layer = lyr1, quiet = TRUE) %>%
st_transform(crs) %>%
sfc2bb(crs = crs)
# Check for proximity of other cities
if(any(st_intersects(c$geom, cityBound, sparse = FALSE)))
tmpDf <- tibble(tile_dir = i) %>%
bind_rows(tmpDf)
}
return(tmpDf)
}
sfc2bb <- function(sfc_object, crs)
{
require(sf)
require(dplyr)
bb <- st_bbox(sfc_object)
list(rbind(c(bb$xmin, bb$ymin),
c(bb$xmax, bb$ymin),
c(bb$xmax, bb$ymax),
c(bb$xmin, bb$ymax),
c(bb$xmin, bb$ymin))) %>%
sf::st_polygon() %>%
sf::st_sfc() %>%
sf::st_sf(crs = crs) %>%
return()
}
# GET DIRECTORIES OF OSM FILES INSIDE UA BOUNDARY
osm_file_list <-
list.files(osm_directory, pattern = city_code, full.names = TRUE) %>%
proximity_checker(city_boundary = ua_directory, city_code = city_code,
osm_file = .)
osm_file_list
osm_file_list$tile_dir
# Load required packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
# Load city boundary
cb_file <- city_boundary %>%
list.files(pattern = city_code,
full.names = TRUE) %>%
list.files(pattern = "gpkg$",
full.names = TRUE,
recursive = TRUE)
proximity_checker <- function(city_boundary, osm_file, city_code, crs = 3035)
{
# Load required packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
# Load city boundary
cb_file <- city_boundary %>%
list.files(pattern = city_code,
full.names = TRUE) %>%
list.files(pattern = "gpkg$",
full.names = TRUE,
recursive = TRUE)
lyr <- st_layers(cb_file)$name[3]
cityBound <- st_read(cb_file, lyr, quiet = TRUE) %>%
st_transform(crs)
# User communication
message("Checking proximity")
tmpDf <- tibble()
for (i in osm_file) {
# Filter for desired city
lyr_tbl <- st_layers(i)
x <- which.max(lyr_tbl$features)
lyr1 <- lyr_tbl$name[x]
c <- st_read(i, layer = lyr1, quiet = TRUE) %>%
st_transform(crs) %>%
sfc2bb(crs = crs)
# Check for proximity of other cities
if(any(st_intersects(c$geom, cityBound, sparse = FALSE)))
tmpDf <- tibble(tile_dir = i) %>%
bind_rows(tmpDf)
}
return(tmpDf)
}
# GET DIRECTORIES OF OSM FILES INSIDE UA BOUNDARY
osm_file_list <-
list.files(osm_directory, pattern = city_code, full.names = TRUE) %>%
proximity_checker(city_boundary = ua_directory, city_code = city_code,
osm_file = .)
osm_file_list
city_bound <- "E:/citiesEurope/Cities.shp"
# Load city boundary
cityBound <- cityBoundLoader(city_boundaries = city_boundary, city_code = city_code,
code_string = "URAU_CO")
cityBoundLoader <- function(city_boundaries, city_code = NULL, buffer_dist = 0,
code_string = "FUA_CO", crs = 3035)
{
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
if (class(city_boundaries) == "character")  {
cityBound <- st_read(city_boundaries, quiet = TRUE) } else {
cityBound <- city_boundaries }
# User communication
message("Load city boundary")
cityBound <- select(cityBound, code = matches(code_string)) %>%
st_transform(crs)
if (is.null(city_code)) return(cityBound) else {
cityBound %>%
filter(substr(code, 1, 5) %in% city_code) %>%
st_buffer(buffer_dist) %>%
return() }
}
# Load city boundary
cityBound <- cityBoundLoader(city_boundaries = city_boundary, city_code = city_code,
code_string = "URAU_CO")
city_code
class(city_boundaries)
city_boundaries <- city_bound
class(city_boundaries) == "character"
if (class(city_boundaries) == "character")  {
cityBound <- st_read(city_boundaries, quiet = TRUE) } else {
cityBound <- city_boundaries }
cityBound
code_string = "URAU_CO"
select(cityBound, code = matches(code_string))
cityBound <- select(cityBound, code = matches(code_string)) %>%
st_transform(crs)
crs = 3035
cityBound <- select(cityBound, code = matches(code_string)) %>%
st_transform(crs)
is.null(city_code)
cityBound
buffer_dist = 0
cityBound %>%
filter(substr(code, 1, 5) %in% city_code) %>%
st_buffer(buffer_dist)
cityBoundLoader <- function(city_boundaries, city_code = NULL, buffer_dist = 0,
code_string = "FUA_CO", crs = 3035)
{
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
if (class(city_boundaries) == "character")  {
cityBound <- st_read(city_boundaries, quiet = TRUE) } else {
cityBound <- city_boundaries }
# User communication
message("Load city boundary")
cityBound <- select(cityBound, code = matches(code_string)) %>%
st_transform(crs)
if (is.null(city_code)) return(cityBound) else {
cityBound %>%
filter(substr(code, 1, 5) %in% city_code) %>%
st_buffer(buffer_dist) %>%
return() }
}
city_boundary
# Load city boundary
cityBound <- cityBoundLoader(city_boundaries = city_boundary, city_code = city_code,
code_string = "URAU_CO")
cityBoundLoader <- function(city_boundaries, city_code = NULL, buffer_dist = 0,
code_string = "FUA_CO", crs = 3035)
{
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
if (class(city_boundaries) == "character")  {
cityBound <- st_read(city_boundaries, quiet = TRUE) } else {
cityBound <- city_boundaries }
# User communication
message("Load city boundary")
cityBound <- select(cityBound, code = matches(code_string)) %>%
mutate(code = substr(code, 1, 5)) %>%
st_transform(crs)
if (is.null(city_code)) return(cityBound) else {
cityBound %>%
filter(code %in% city_code) %>%
st_buffer(buffer_dist) %>%
return() }
}
# Load city boundary
cityBound <- cityBoundLoader(city_boundaries = city_boundary, city_code = city_code,
code_string = "URAU_CO")
cityBound
cityBoundLoader <- function(city_boundaries, city_code = NULL, buffer_dist = 0,
code_string = "FUA_CO", crs = 3035)
{
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
if (class(city_boundaries) == "character")  {
cityBound <- st_read(city_boundaries, quiet = TRUE) } else {
cityBound <- city_boundaries }
# User communication
message("Load city boundary")
cityBound <- cityBound %>%
select(code = matches(code_string)) %>%
mutate(code = substring(code, 1, 5)) %>%
st_transform(crs)
if (is.null(city_code)) return(cityBound) else {
cityBound %>%
filter(code %in% city_code) %>%
st_buffer(buffer_dist) %>%
return() }
}
# Load city boundary
cityBound <- cityBoundLoader(city_boundaries = city_boundary, city_code = city_code,
code_string = "URAU_CO")
cityBoundLoader <- function(city_boundaries, city_code = NULL, buffer_dist = 0,
code_string = "FUA_CO", crs = 3035)
{
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
if (class(city_boundaries) == "character")  {
cityBound <- st_read(city_boundaries, quiet = TRUE) } else {
cityBound <- city_boundaries }
# User communication
message("Load city boundary")
cityBound <- cityBound %>%
select(code = matches(code_string)) %>%
mutate(code = substr(cityBound$code, 1, 5)) %>%
st_transform(crs)
if (is.null(city_code)) return(cityBound) else {
cityBound %>%
filter(code %in% city_code) %>%
st_buffer(buffer_dist) %>%
return() }
}
# Load city boundary
cityBound <- cityBoundLoader(city_boundaries = city_boundary, city_code = city_code,
code_string = "URAU_CO")
city_boundary
city_code
# OVERVIEW:
# 1. READ UA 2018 DATA
# 2. READ OSM BUILDING TILE
# 3. FILTER OSM BUILDINGS FOR INSIDE UA RESIDENTIAL POLYGONS
# 4. ADD POPULATION FROM URBAN ATLAS
# 5. ADD BUILDING ID
#
################################################################################
# INPUT VALUES FOR TESTING CODE
# DATA DIRECTORIES FOR UA AND OSM DATA
osm_dir <-  "E:/osm_buildings/"
city_bound <- "E:/citiesEurope/Cities.shp"
ua_dir <- "C:/Berlin/UA2018/"
net_dir <- "C:/Berlin/network_clean.gpkg"
# FUA CITY CODE
cityCode <- "DE001"
outDir <- "C:/Berlin/popTiles/"
city_boundaries = city_boundary
osm_directory = osm_dir
ua_directory = ua_dir
out_dir = outDir
city_code = cityCode
city_boundaries = city_bound
city_boundaries = city_boundary
city_boundary = city_bound
# Load city boundary
cityBound <- cityBoundLoader(city_boundaries = city_boundary, city_code = city_code,
code_string = "URAU_CO")
# LOAD PACKAGES AND FUNCTIONS
require(dplyr, quietly = TRUE)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-2[A-Za-z].*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
# Load city boundary
cityBound <- cityBoundLoader(city_boundaries = city_boundary, city_code = city_code,
code_string = "URAU_CO")
cityBound
# GET DIRECTORIES OF OSM FILES INSIDE UA BOUNDARY
osm_file_list <-
list.files(osm_directory, pattern = city_code, full.names = TRUE) %>%
proximity_checker(city_boundary = cityBound, city_code = city_code,
osm_file = .)
sfc2bb <- function(sfc_object, crs = 3035)
{
require(sf)
require(dplyr)
bb <- st_bbox(sfc_object)
list(rbind(c(bb$xmin, bb$ymin),
c(bb$xmax, bb$ymin),
c(bb$xmax, bb$ymax),
c(bb$xmin, bb$ymax),
c(bb$xmin, bb$ymin))) %>%
sf::st_polygon() %>%
sf::st_sfc() %>%
sf::st_sf(crs = crs) %>%
return()
}
# GET DIRECTORIES OF OSM FILES INSIDE UA BOUNDARY
osm_file_list <-
list.files(osm_directory, pattern = city_code, full.names = TRUE) %>%
proximity_checker(city_boundary = cityBound, city_code = city_code,
osm_file = .)
OSMfilter <- function(osm_buildings, ua_residential, city_boundaries)
{
# required packages
require(dplyr)
require(sf)
# bildings that are not residential
not_res <- c("^mall$", "train_station", "garages", "hospital",
"parking", "sports_centre", "university", "gas_station",
"school", "hall", "government", "prison", "sports_hall",
"carport", "garbage", "waste")
# user communication
message("\n filtering OSM buildings... \n")
# filtering
osm_buildings %>%
st_filter(cityBound, .pred = st_intersects) %>%
st_join(ua_residential) %>%
# filter OSM buildings inside UA residential polygons
filter(!is.na(code_2018)) %>%
# filter OSM buildings with non residential classes
filter(!(building %in% not_res)) %>%
select(Pop2018, identifier, code_2018) %>%
return()
}
osm_file_list
# 1. READ UA 2018 DATA
#    -> FILTER FOR RESIDENTIAL AREAS
UAresidential <- UAresLoader(ua_directory)
out_dir
# 2. READ OSM BUILDING TILE
#    -> CHECK IF OSM LAYER IS INSIDE CITY BOUNDARIES
#    -> UNITE LAYERS IF NECESSARY
for(osm_file in osm_file_list$tile_dir) {
tmpDir <- paste0(out_dir, strsplit(osm_file, "/")[[1]] %>% last())
osm_file %>%
OSMloader() %>%
# 3. FILTER OSM BUILDINGS FOR INSIDE UA RESIDENTIAL POLYGONS
OSMfilter(ua_residential = UAresidential, city_boundaries = cityBound) %>%
# 4. ADD POPULATION FROM URBAN ATLAS
#    -> 1. FROM UA POLYGON
#    -> 2. FROM AVERAGE POP / AREA IN TILE (IF NO POP INFO AT POLYGON)
OSMpop() %>%
# 5. ADD BUILDING ID
#    -> IDENTIFIER + NUMBER
OSMbuildID() %>%
st_write(tmpDir, quiet = TRUE)
}

comp_df_beetles %>%
transmute(species_name = paste(family, species)) %>%
distinct() %>%
mutate(bb = TRUE)
drought_spec <-
comp_df_drought %>%
transmute(species_name = paste(family, species)) %>%
distinct() %>%
mutate(drought = TRUE)
full_join(drought_spec, bb_spec)
comp_df <- full_join(drought_spec, bb_spec)
View(comp_df)
comp_df %>%
filter(drought & bb)
install.packages("taxise")
install.packages("taxize")
library(taxize)
taxize::synonyms(bb_spec$species_name)
taxize::synonyms_df(bb_spec$species_name)
?syno
?synonyms
taxize::synonyms(bb_spec$species_name, db="itis")
bb_syn <-
taxize::synonyms(bb_spec$species_name, db="itis")
View(bb_syn)
bb_syn[["Abies subalpina"]][["syn_name"]]
bb_spec %>%
filter(substr(species_name, 1, 5) %in% substr(drought_spec$species_name, 1, 5)) %>% nrow()
bb_spec <-
comp_df_beetles %>%
transmute(species_name = paste(family, species)) %>%
distinct() %>%
mutate(bb = TRUE,
spec_nam_short = paste(family, substr(species, 1, 5)))
drought_spec <-
comp_df_drought %>%
transmute(species_name = paste(family, species)) %>%
distinct() %>%
mutate(drought = TRUE,
spec_nam_short = paste(family, substr(species, 1, 5)))
bb_spec <-
comp_df_beetles %>%
transmute(species_name = paste(family, species)) %>%
distinct() %>%
mutate(bb = TRUE,
spec_short = substr(species, 1, 5)
spec_nam_short = paste(family, spec_short))
bb_spec <-
comp_df_beetles %>%
transmute(species_name = paste(family, species)) %>%
distinct() %>%
mutate(bb = TRUE,
spec_short = substr(species, 1, 5),
spec_nam_short = paste(family, spec_short))
bb_spec <-
comp_df_beetles %>%
mutate(species_name = paste(family, species)) %>%
distinct() %>%
mutate(bb = TRUE,
spec_short = substr(species, 1, 5),
spec_nam_short = paste(family, spec_short))
drought_spec <-
comp_df_drought %>%
mutate(species_name = paste(family, species)) %>%
distinct() %>%
mutate(droght = TRUE,
spec_short = substr(species, 1, 5),
spec_nam_short = paste(family, spec_short))
bb_spec <-
comp_df_beetles %>%
mutate(species_name = paste(family, species)) %>%
distinct() %>%
mutate(bb = TRUE,
spec_short = substr(species, 1, 5),
spec_nam_short = paste(family, spec_short))
drought_spec
bb_spec %>%
filter(spec_name_short %in% drought_spec$spec_name_short) %>% nrow()
bb_spec %>%
filter(spec_nam_short %in% drought_spec$spec_nam_short) %>% nrow()
bb_spec %>%
filter(species_name %in% drought_spec$species_name) %>% nrow()
bb_spec <-
comp_df_beetles %>%
mutate(species_name = paste(family, species)) %>%
distinct() %>%
mutate(bb = TRUE,
spec_short = substr(species, 1, 5),
spec_nam_short = paste(family, spec_short)) %>%
select(species_name, spec_short)
bb_spec <-
comp_df_beetles %>%
mutate(species_name = paste(family, species)) %>%
distinct() %>%
mutate(bb = TRUE,
spec_short = substr(species, 1, 5),
spec_nam_short = paste(family, spec_short)) %>%
select(species_name, spec_nam_short)
drought_spec <-
comp_df_drought %>%
mutate(species_name = paste(family, species)) %>%
distinct() %>%
mutate(droght = TRUE,
spec_short = substr(species, 1, 5),
spec_nam_short = paste(family, spec_short)) %>%
select(species_name, spec_nam_short)
comp_df <- full_join(drought_spec, bb_spec)
comp_df <- full_join(drought_spec, bb_spec, by = "spec_nam_short")
View(comp_df)
# LIST NETWORK TILES FOR CITY CODE
# LOAD AND COMBINE NETWORK TILES
#    -> CHECK IF TILE IS INSIDE CITY CORE
#    -> COMBINE NETWORK TILES
# CLEAN NETWORK
#    -> DOUBLE ENTRIES
#    -> UNCONNECTED EDGES
################################################################################
# INPUT VALUES FOR TESTING CODE
# DATA DIRECTORIES FOR UA AND OSM DATA
boundaryFile <- "E:/citiesEurope/Cities.shp"
netTileDir <- "E:/osm_paths/"
# FUA CITY CODE
cityCode <- "DE001"
#buildingEntries(osm_directory = osm_dir, ua_directory = ua_dir,
#                city_code = cityCode)
################################################################################
# LOAD PACKAGES AND FUNCTIONS
require(dplyr, quietly = TRUE)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-1[A-Za-z].*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-1[A-Za-z].*\\.R", full.names = TRUE) %>%
for (file in .) source(file, quietly = TRUE)
# temp directory for output
tempdir()
# temp directory for output
tmpOut <- paste0(tempdir(), "\\\\tmp-path.gpkg")
tmpOut
# temp directory for output
tmpOut <- paste0(tempdir(), "\\tmp-path.gpkg")
tmpOut
combinator <- function(file_list, boundary = NULL, crs = 3035)
{
# load packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
# temp directory for output
tmpOut <- paste0(tempdir(), "\\tmp-path.gpkg")
if(dir.exists(tmpOut)) unlink(tmpOut)
# iterate through files
for (file in file_list) {
# check layers
lr <- st_layers(file)$name %>%
grep("line", .,
ignore.case = TRUE, value = TRUE)
# read file
tmp <- file %>%
st_read(quiet = TRUE, layer = lr[1]) %>%
st_transform(crs)
# check if tmp is inside boundary
isIn <- ifelse(is.null(boundary), TRUE,
any(st_intersects(tmp$geom, boundary, sparse = FALSE)))
# combine
if (isIn) tmp %>%
select(highway = matches("^highway$")) %>%
filter(!grepl("motorway", highway)) %>%
st_write(dsn = tmpOut, layer = "osm_paths",
quiet = TRUE, append = TRUE)}
# clear temp object
rm(tmp)
# read output and return
tmpOut %>%
st_read(quiet = TRUE) %>%
return()
}
# LOAD CITY CORE BOUNDARY
cityBoundary <- boundaryLoader(boundaryFile, cityCode)
cityBoundary
# LIST NETWORK TILES FOR FUA CODE
netTiles <- listTiles(netTileDir, cityCode)
# LOAD AND COMBINE NETWORK TILES
network <- combinator(netTiles, cityBoundary)
network
unlink(tmpOut)
st_write(network, "E:/network_test.gpkg")
combinator <- function(file_list, boundary = NULL, crs = 3035)
{
# load packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
# temp directory for output
tmpOut <- paste0(tempdir(), "\\tmp-path.gpkg")
if(dir.exists(tmpOut)) unlink(tmpOut)
# iterate through files
for (file in file_list) {
# check layers
lr <- st_layers(file)$name %>%
grep("line", .,
ignore.case = TRUE, value = TRUE)
# read file
tmp <- file %>%
st_read(quiet = TRUE, layer = lr[1]) %>%
st_transform(crs)
# check if tmp is inside boundary
isIn <- ifelse(is.null(boundary), TRUE,
any(st_intersects(tmp$geom, boundary, sparse = FALSE)))
# combine
if (isIn) tmp %>%
select(highway = matches("^highway$")) %>%
filter(!grepl("motorway", highway)) %>%
st_write(dsn = tmpOut, layer = "osm_paths",
quiet = TRUE, append = TRUE)}
# clear temp object
rm(tmp)
# read output and return
output <-
st_read(quiet = TRUE) %>%
st_filter(boundary, .pred = st_intersects)
unlink(tmpOut)
return(output)
}
# LOAD AND COMBINE NETWORK TILES
network <- combinator(netTiles, cityBoundary)
combinator <- function(file_list, boundary = NULL, crs = 3035)
{
# load packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
# temp directory for output
tmpOut <- paste0(tempdir(), "\\tmp-path.gpkg")
if(dir.exists(tmpOut)) unlink(tmpOut)
# iterate through files
for (file in file_list) {
# check layers
lr <- st_layers(file)$name %>%
grep("line", .,
ignore.case = TRUE, value = TRUE)
# read file
tmp <- file %>%
st_read(quiet = TRUE, layer = lr[1]) %>%
st_transform(crs)
# check if tmp is inside boundary
isIn <- ifelse(is.null(boundary), TRUE,
any(st_intersects(tmp$geom, boundary, sparse = FALSE)))
# combine
if (isIn) tmp %>%
select(highway = matches("^highway$")) %>%
filter(!grepl("motorway", highway)) %>%
st_write(dsn = tmpOut, layer = "osm_paths",
quiet = TRUE, append = TRUE)}
# clear temp object
rm(tmp)
# read output and return
output <- tmpOut %>%
st_read(quiet = TRUE) %>%
st_filter(boundary, .pred = st_intersects)
unlink(tmpOut)
return(output)
}
# LOAD AND COMBINE NETWORK TILES
network <- combinator(netTiles, cityBoundary)
st_write(network, "E:/network_test1.gpkg")
require(sf)
require(sfnetworks)
networkCleaner <- function(network, crs = 3035)
{
require(dplyr)
require(sf)
require(sfnetworks)
baseDir <- "C:/Berlin/"
net_clean <-
network %>%
st_transform(crs) %>%
distinct() %>%
st_cast("LINESTRING") %>%
as_sfnetwork() %>%
filter(group_components() == 1) %>%
activate("edges") %>%
as_tibble() %>%
st_as_sf() %>%
st_geometry() %>%
lapply(function(x) round(x, 0)) %>%
st_sfc(crs = 3035) %>%
as_sfnetwork() %>%
convert(to_spatial_smooth) %>%
convert(to_spatial_subdivision)
}
# CLEAN NETWORK
#    -> DOUBLE ENTRIES
#    -> UNCONNECTED EDGES
network %>% networkCleaner(network)
networkCleaner <- function(network, crs = 3035)
{
require(dplyr)
require(sf)
require(sfnetworks)
baseDir <- "C:/Berlin/"
net_clean <-
network %>%
st_transform(crs) %>%
distinct() %>%
st_cast("LINESTRING") %>%
as_sfnetwork() %>%
filter(group_components() == 1) %>%
activate("edges") %>%
as_tibble() %>%
st_as_sf() %>%
st_geometry() %>%
lapply(function(x) round(x, 0)) %>%
st_sfc(crs = 3035) %>%
as_sfnetwork() %>%
convert(to_spatial_smooth) %>%
convert(to_spatial_subdivision)
}
network
# CLEAN NETWORK
#    -> DOUBLE ENTRIES
#    -> UNCONNECTED EDGES
network %>% networkCleaner(network)
network %>%
st_transform(crs)
crs = 3035
require(dplyr)
require(sf)
require(sfnetworks)
network %>%
st_transform(crs)
network %>%
distinct() %>%
st_cast("LINESTRING") %>%
as_sfnetwork() %>%
filter(group_components() == 1) %>%
activate("edges") %>%
as_tibble() %>%
st_as_sf() %>%
st_geometry() %>%
lapply(function(x) round(x, 0)) %>%
st_sfc(crs = 3035) %>%
as_sfnetwork() %>%
convert(to_spatial_smooth) %>%
convert(to_spatial_subdivision) %>%
return()
networkCleaner <- function(network, crs = 3035)
{
# load packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
require(tidygraph, quietly = TRUE)
require(sfnetworks, quietly = TRUE)
# network cleaning
network %>%
# remove double entries
distinct() %>%
# make sure no MULTILINESTRINGS in network
st_cast("LINESTRING") %>%
st_geometry() %>%
# make sure point coordinates match
lapply(function(x) round(x, 0)) %>%
st_sfc(crs = 3035) %>%
# remove unconnected edges
as_sfnetwork() %>%
filter(group_components() == 1) %>%
#activate("nodes") %>%
# subdivide edges at interior points
#activate("edges") %>%
#convert(to_spatial_subdivision) %>%
# remove pseudo nodes
convert(to_spatial_smooth) %>%
return()
}
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
require(tidygraph, quietly = TRUE)
require(sfnetworks, quietly = TRUE)
net <- st_read("E:/network_test1.gpkg")
net_clean <- networkCleaner(net)
net_clean %>% activate("edges") %>% st_as_sf() %>% st_write("E:/net_clean_test3.gpkg")
net_clean
net_clean %>% activate("edges") %>% select(x) %>%  st_as_sf() %>% st_write("E:/net_clean_test3.gpkg")
networkCleaner <- function(network, crs = 3035)
{
# load packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
require(tidygraph, quietly = TRUE)
require(sfnetworks, quietly = TRUE)
# network cleaning
network %>%
# remove double entries
distinct() %>%
# make sure no MULTILINESTRINGS in network
st_cast("LINESTRING") %>%
st_geometry() %>%
# make sure point coordinates match
lapply(function(x) round(x, 0)) %>%
st_sfc(crs = 3035) %>%
# remove unconnected edges
as_sfnetwork() %>%
#filter(group_components() == 1) %>%
#activate("nodes") %>%
# subdivide edges at interior points
#activate("edges") %>%
convert(to_spatial_subdivision) %>%
# remove pseudo nodes
convert(to_spatial_smooth) %>%
return()
}
net_clean <- networkCleaner(net)
net_clean
net_clean %>% filter(group_components() == 1)
net_clean %>% filter(group_components() == 1) %>% activate("edges") %>% st_as_sf()
net_clean %>% filter(group_components() == 1) %>% activate("edges") %>% st_as_sf() %>% st_write("E:/net_clean_test4.gpkg")
net_clean %>% filter(group_components() == 1) %>% activate("edges") %>% select(x) %>% st_as_sf() %>% st_write("E:/net_clean_test4.gpkg")
networkCleaner <- function(network, crs = 3035)
{
# load packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
require(tidygraph, quietly = TRUE)
require(sfnetworks, quietly = TRUE)
# network cleaning
network %>%
# remove double entries
distinct() %>%
# make sure no MULTILINESTRINGS in network
st_cast("LINESTRING") %>%
st_geometry() %>%
# make sure point coordinates match
lapply(function(x) round(x, 0)) %>%
st_sfc(crs = 3035) %>%
as_sfnetwork() %>%
# subdivide edges at interior points
convert(to_spatial_subdivision) %>%
# remove pseudo nodes
convert(to_spatial_smooth) %>%
# remove unconnected edges
filter(group_components() == 1) %>%
return()
}
networkCleaner(net)
rm(net, net_clean)
# LIST NETWORK TILES FOR CITY CODE
# LOAD AND COMBINE NETWORK TILES
#    -> CHECK IF TILE IS INSIDE CITY CORE
#    -> COMBINE NETWORK TILES
# CLEAN NETWORK
#    -> DOUBLE ENTRIES
#    -> UNCONNECTED EDGES
################################################################################
# INPUT VALUES FOR TESTING CODE
# DATA DIRECTORIES FOR UA AND OSM DATA
boundaryFile <- "E:/citiesEurope/Cities.shp"
netTileDir <- "E:/osm_paths/"
# FUA CITY CODE
cityCode <- "DE001"
net <- networkCleaner(network_tile_dir = netTileDir,
boundary_file = boundaryFile,
city_code = cityCode)
networkCleaner <- function(network_tile_dir, boundary_file, city_code)
{
# LOAD PACKAGES AND FUNCTIONS
require(dplyr, quietly = TRUE)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-1[A-Za-z].*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
# LOAD CITY CORE BOUNDARY
cityBoundary <- boundaryLoader(boundary_file = boundary_file,
city_code = city_code)
# LIST NETWORK TILES FOR FUA CODE
listTiles(network_tile_directory = network_tile_dir,
city_code = city_code) %>%
# LOAD AND COMBINE NETWORK TILES
combinator(file_list = ., boundary = cityBoundary) %>%
# CLEAN NETWORK
#    -> DOUBLE ENTRIES
#    -> UNCONNECTED EDGES
networkCleaner() %>%
return()
}
net <- networkCleaner(network_tile_dir = netTileDir,
boundary_file = boundaryFile,
city_code = cityCode)
networkPrep <- function(network_tile_dir, boundary_file, city_code)
{
# LOAD PACKAGES AND FUNCTIONS
require(dplyr, quietly = TRUE)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-1[A-Za-z].*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
# LOAD CITY CORE BOUNDARY
cityBoundary <- boundaryLoader(boundary_file = boundary_file,
city_code = city_code)
# LIST NETWORK TILES FOR FUA CODE
listTiles(network_tile_directory = network_tile_dir,
city_code = city_code) %>%
# LOAD AND COMBINE NETWORK TILES
combinator(file_list = ., boundary = cityBoundary) %>%
# CLEAN NETWORK
#    -> DOUBLE ENTRIES
#    -> UNCONNECTED EDGES
networkCleaner() %>%
return()
}
net <- networkPrep(network_tile_dir = netTileDir,
boundary_file = boundaryFile,
city_code = cityCode)
net

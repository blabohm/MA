# require(igraph)
# require(tidygraph)
# Tile boundaries
cityGrid <- city_boundary %>%
st_transform(crs) %>%
st_buffer(1000) %>%
st_make_grid(cellsize = cellsize) %>%
st_as_sf() %>%
st_filter(city_boundary, .pred = st_intersects)
# Iterate through city tiles
for (i in 1:nrow(cityGrid)) {
# User communication
message(paste(i, "of", nrow(cityGrid)))
# Intersect input with grid
# Buildings
build_tile <-
build_entries %>%
st_transform(crs) %>%
st_intersection(cityGrid$x[i]) %>%
st_cast("POINT")
# Green space entries
gs_tile <-
gs_entries %>%
st_transform(crs) %>%
st_intersection(cityGrid$x[i]) %>%
st_cast("POINT")
# Network
gb <- st_buffer(cityGrid$x[i], 100)
net_tile <-
network %>%
st_transform(crs) %>%
st_filter(gb, .predicate = st_intersects) %>%
st_cast("LINESTRING")
# Snap buildings and green space entries to network
if (nrow(build_tile) > 0) {
build_snap <- st_snap_points(points = build_tile, lines = net_tile)
} else build_snap <- NULL
if (nrow(gs_tile) > 0) {
gs_snap <- st_snap_points(points = gs_tile, lines = net_tile)
} else gs_snap <- NULL
# Make sure object is not empty
if (is.null(build_snap)) {nodes <- gs_snap
} else if (is.null(gs_snap)) {nodes <- build_snap}  else {
nodes <- bind_rows(build_snap, gs_snap)}
# Blend buildings and green space entries to network
tile_blend <-
as_sfnetwork(net_tile) %>%
st_network_blend(y = nodes)
# Write results to temp file
tile_blend %>%
activate("edges") %>%
st_as_sf() %>%
st_write(edge_out, layer = "edges", quiet = TRUE, append = TRUE)
tile_blend %>%
activate("nodes") %>%
st_as_sf() %>%
st_write(node_out, layer = "nodes", quiet = TRUE, append = TRUE)
# Clean up
rm(tile_blend, nodes, net_tile, gs_tile, gs_snap,
build_tile, build_snap)
gc()
}
}
outDir <- "C:/Berlin/net_blend/"
output_dir = outDir
if (!dir.exists(output_dir)) dir.create(output_dir)
output_dir
snapAndBlend <- function(city_boundary, build_entries, gs_entries, network,
cellsize = 3000, output_dir, crs = 3035)
{
# Load required packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
require(sfnetworks, quietly = TRUE)
# require(igraph)
# require(tidygraph)
# output directories:
edge_out <- paste0(output_dir, "edges.gpkg")
node_out <- paste0(output_dir, "nodes.gpkg")
# Tile boundaries
cityGrid <- city_boundary %>%
st_transform(crs) %>%
st_buffer(1000) %>%
st_make_grid(cellsize = cellsize) %>%
st_as_sf() %>%
st_filter(city_boundary, .pred = st_intersects)
# Iterate through city tiles
for (i in 1:nrow(cityGrid)) {
# User communication
message(paste(i, "of", nrow(cityGrid)))
# Intersect input with grid
# Buildings
build_tile <-
build_entries %>%
st_transform(crs) %>%
st_intersection(cityGrid$x[i]) %>%
st_cast("POINT")
# Green space entries
gs_tile <-
gs_entries %>%
st_transform(crs) %>%
st_intersection(cityGrid$x[i]) %>%
st_cast("POINT")
# Network
gb <- st_buffer(cityGrid$x[i], 100)
net_tile <-
network %>%
st_transform(crs) %>%
st_filter(gb, .predicate = st_intersects) %>%
st_cast("LINESTRING")
# Snap buildings and green space entries to network
if (nrow(build_tile) > 0) {
build_snap <- st_snap_points(points = build_tile, lines = net_tile)
} else build_snap <- NULL
if (nrow(gs_tile) > 0) {
gs_snap <- st_snap_points(points = gs_tile, lines = net_tile)
} else gs_snap <- NULL
# Make sure object is not empty
if (is.null(build_snap)) {nodes <- gs_snap
} else if (is.null(gs_snap)) {nodes <- build_snap}  else {
nodes <- bind_rows(build_snap, gs_snap)}
# Blend buildings and green space entries to network
tile_blend <-
as_sfnetwork(net_tile) %>%
st_network_blend(y = nodes)
# Write results to temp file
tile_blend %>%
activate("edges") %>%
st_as_sf() %>%
st_write(edge_out, layer = "edges", quiet = TRUE, append = TRUE)
tile_blend %>%
activate("nodes") %>%
st_as_sf() %>%
st_write(node_out, layer = "nodes", quiet = TRUE, append = TRUE)
# Clean up
rm(tile_blend, nodes, net_tile, gs_tile, gs_snap,
build_tile, build_snap)
gc()
}
}
# SNAP AND BLEND BUILDING AND PARK ENTRIES TO NETWORK
snapAndBlend(city_boundary = city_boundary, build_entries = bEntries,
gs_entries = gsEntries, network = OSMnetwork, out_dir = outDir)
# SNAP AND BLEND BUILDING AND PARK ENTRIES TO NETWORK
snapAndBlend(city_boundary = city_boundary, build_entries = bEntries,
gs_entries = gsEntries, network = OSMnetwork,
output_dir = outDir)
################################################################################
# OVERVIEW:
# CONVERT TO BUILDING CENTROID
# READ OSM NETWORK
# OUTPUT TO TEMP
################################################################################
netDir <- "C:/Berlin/network_clean1.gpkg"
gsDir <- "C:/Berlin/green_space_entries.gpkg"
beDir <- "C:/Berlin/buildings.gpkg"
outDir <- "C:/Berlin/net_blend/"
cityBound <- "C:/Berlin/cities.gpkg"
city_code <- "DE001"
# LOAD PACKAGES AND FUNCTIONS
require(dplyr, quietly = TRUE, warn.conflicts = FALSE)
require(sf, quietly = TRUE)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-4[A-Za-z].*\\.R|2_.*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
################################################################################
# 6. CONVERT TO BUILDING CENTROID
#    -> POINT ON SURFACE
#    -> SNAP BUILDING CENTROIDS TO NETWORK
# 8. OUTPUT TO TEMP
################################################################################
#out_dir <- "C:/Berlin/tiles/"
city_boundary <- "C:/Berlin/cities.gpkg"
city_code <- "DE001"
build_entries <- "C:/Berlin/buildings_cent.gpkg"
gs_entries <- "C:/Berlin/green_space_entries2.gpkg"
network <- "C:/Berlin/network_clean1.gpkg"
output_dir <- "C:/Berlin/net_blend/"
cellsize = 1000
crs = 3035
# Load required packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
require(sfnetworks, quietly = TRUE)
require(doParallel, quietly = TRUE)
bound_query <- paste0('SELECT * FROM \'cities\' WHERE URAU_CODE = \'',
city_code, '\'')
city_boundary <- city_boundary %>%
st_read(query = bound_query, quiet = TRUE) %>%
st_transform(crs)
# Tile boundaries
cityGrid <- city_boundary %>%
st_buffer(1000) %>%
st_make_grid(cellsize = cellsize) %>%
st_as_sf() %>%
st_filter(city_boundary, .pred = st_intersects)
#ncore <- 2
#cl <- makeCluster(ncore, outfile = "")
#registerDoParallel(cl)
# Iterate through city tiles
for (i in 725:nrow(cityGrid)) { # 13:05
#foreach(i = 1:nrow(cityGrid), .combine = rbind) %dopar% ({
require(dplyr)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-4[A-Za-z].*\\.R|2_.*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
# output directories:
#edge_out <- paste0(output_dir, "edges", i, ".gpkg")
#node_out <- paste0(output_dir, "nodes", i, ".gpkg")
edge_out <- paste0(output_dir, "edges.gpkg")
node_out <- paste0(output_dir, "nodes.gpkg")
#node_missed_out <- paste0(output_dir, "nodes_missed.gpkg")
# User communication
message(paste(i, "of", nrow(cityGrid)))
# Intersect input with grid
gridBox <- cityGrid[i,] %>%
sf::st_geometry() %>%
sf::st_as_text()
# Buildings
build_tile <- build_entries %>%
sf::st_read(wkt_filter = gridBox, quiet = TRUE) %>%
sf::st_cast("POINT")
# Green space entries
gs_tile <- gs_entries %>%
sf::st_read(wkt_filter = gridBox, quiet = TRUE) %>%
sf::st_cast("POINT")
# Network (with buffer to avoid errors at edges)
gridBox1 <- cityGrid[i,] %>%
sf::st_buffer(100, nQuadSegs = 1) %>%
sf::st_geometry() %>%
sf::st_as_text()
net_tile <- network %>%
sf::st_read(wkt_filter = gridBox1, quiet = TRUE) %>%
sf::st_cast("LINESTRING")
# Snap buildings and green space entries to network
if (nrow(build_tile) > 0) {
build_snap <- st_snap_points(points = build_tile, lines = net_tile)
} else build_snap <- NULL
if (nrow(gs_tile) > 0) {
gs_snap <- st_snap_points(points = gs_tile, lines = net_tile)
} else gs_snap <- NULL
# Make sure object is not empty
if (is.null(build_snap) & is.null(gs_snap)) next
if (is.null(build_snap)) {nodes <- mutate(gs_snap, population = NA, ID = NA)
} else if (is.null(gs_snap)) {nodes <- mutate(build_snap, city_code = NA,
class = NA, identifier = NA,
area = NA)}  else {
nodes <- dplyr::bind_rows(build_snap, gs_snap) %>%
dplyr::distinct()}
# Blend buildings and green space entries to network
edges <- sf::st_collection_extract(lwgeom::st_split(net_tile, sf::st_buffer(nodes, 1e-5)),
"LINESTRING")
st_geometry(edges) <- edges %>%
st_geometry() %>%
lapply(function(x) round(x, 0)) %>%
st_sfc(crs = 3035)
edges <- distinct(edges)
st_geometry(nodes) <- nodes %>%
st_geometry() %>%
lapply(function(x) round(x, 0)) %>%
st_sfc(crs = 3035)
nodes <- distinct(nodes)
# nodes_net <- edges %>%
#   as_sfnetwork() %>%
#   activate("nodes") %>%
#   st_join(nodes) %>%
#   st_as_sf()
st_write(nodes, node_out, quiet = TRUE, append = TRUE)
st_write(edges, edge_out, quiet = TRUE, append = TRUE)
# if (nrow(build_tile) > 0) {
# filter(nodes, !(ID %in% nodes_net$ID)) %>%
#   st_write(node_missed_out, quiet = TRUE, append = TRUE) }
# tile_blend <-
#   as_sfnetwork(net_tile) %>%
#   st_network_blend(y = nodes)
# # Write results to temp file
# tile_blend %>%
#   activate("edges") %>%
#   st_as_sf() %>%
#   st_write(edge_out, layer = "edges", quiet = TRUE, append = TRUE)
# tile_blend %>%
#   activate("nodes") %>%
#   st_as_sf() %>%
#   st_write(node_out, layer = "nodes", quiet = TRUE, append = TRUE)
# Clean up
# rm(tile_blend, nodes, net_tile, gs_tile, gs_snap,
#    build_tile, build_snap)
# gc()
#return(i)
}
cityGrid
#ncore <- 2
#cl <- makeCluster(ncore, outfile = "")
#registerDoParallel(cl)
# Iterate through city tiles
for (i in 725:nrow(cityGrid)) { # 13:05
#foreach(i = 1:nrow(cityGrid), .combine = rbind) %dopar% ({
require(dplyr)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-4[A-Za-z].*\\.R|2_.*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
# output directories:
#edge_out <- paste0(output_dir, "edges", i, ".gpkg")
#node_out <- paste0(output_dir, "nodes", i, ".gpkg")
edge_out <- paste0(output_dir, "edges.gpkg")
node_out <- paste0(output_dir, "nodes.gpkg")
#node_missed_out <- paste0(output_dir, "nodes_missed.gpkg")
# User communication
message(paste(i, "of", nrow(cityGrid)))
# Intersect input with grid
gridBox <- cityGrid[i,] %>%
sf::st_geometry() %>%
sf::st_as_text()
# Buildings
build_tile <- build_entries %>%
sf::st_read(wkt_filter = gridBox, quiet = TRUE) %>%
sf::st_cast("POINT")
# Green space entries
gs_tile <- gs_entries %>%
sf::st_read(wkt_filter = gridBox, quiet = TRUE) %>%
sf::st_cast("POINT")
# Network (with buffer to avoid errors at edges)
gridBox1 <- cityGrid[i,] %>%
sf::st_buffer(100, nQuadSegs = 1) %>%
sf::st_geometry() %>%
sf::st_as_text()
net_tile <- network %>%
sf::st_read(wkt_filter = gridBox1, quiet = TRUE) %>%
sf::st_cast("LINESTRING")
# Snap buildings and green space entries to network
if (nrow(build_tile) > 0) {
build_snap <- st_snap_points(points = build_tile, lines = net_tile)
} else build_snap <- NULL
if (nrow(gs_tile) > 0) {
gs_snap <- st_snap_points(points = gs_tile, lines = net_tile)
} else gs_snap <- NULL
# Make sure object is not empty
if (is.null(build_snap) & is.null(gs_snap)) next
if (is.null(build_snap)) {nodes <- mutate(gs_snap, population = NA, ID = NA)
} else if (is.null(gs_snap)) {nodes <- mutate(build_snap, city_code = NA,
class = NA, identifier = NA,
area = NA)}  else {
nodes <- dplyr::bind_rows(build_snap, gs_snap) %>%
dplyr::distinct()}
# Blend buildings and green space entries to network
edges <- sf::st_collection_extract(lwgeom::st_split(net_tile, sf::st_buffer(nodes, 1e-5)),
"LINESTRING")
st_geometry(edges) <- edges %>%
st_geometry() %>%
lapply(function(x) round(x, 0)) %>%
st_sfc(crs = 3035)
edges <- distinct(edges)
st_geometry(nodes) <- nodes %>%
st_geometry() %>%
lapply(function(x) round(x, 0)) %>%
st_sfc(crs = 3035)
nodes <- distinct(nodes)
# nodes_net <- edges %>%
#   as_sfnetwork() %>%
#   activate("nodes") %>%
#   st_join(nodes) %>%
#   st_as_sf()
st_write(nodes, node_out, quiet = TRUE, append = TRUE)
st_write(edges, edge_out, quiet = TRUE, append = TRUE)
# if (nrow(build_tile) > 0) {
# filter(nodes, !(ID %in% nodes_net$ID)) %>%
#   st_write(node_missed_out, quiet = TRUE, append = TRUE) }
# tile_blend <-
#   as_sfnetwork(net_tile) %>%
#   st_network_blend(y = nodes)
# # Write results to temp file
# tile_blend %>%
#   activate("edges") %>%
#   st_as_sf() %>%
#   st_write(edge_out, layer = "edges", quiet = TRUE, append = TRUE)
# tile_blend %>%
#   activate("nodes") %>%
#   st_as_sf() %>%
#   st_write(node_out, layer = "nodes", quiet = TRUE, append = TRUE)
# Clean up
# rm(tile_blend, nodes, net_tile, gs_tile, gs_snap,
#    build_tile, build_snap)
# gc()
#return(i)
}
#node_missed_out <- paste0(output_dir, "nodes_missed.gpkg")
# User communication
message(paste(i, "of", nrow(cityGrid)))
# Intersect input with grid
gridBox <- cityGrid[i,] %>%
sf::st_geometry() %>%
sf::st_as_text()
# Buildings
build_tile <- build_entries %>%
sf::st_read(wkt_filter = gridBox, quiet = TRUE) %>%
sf::st_cast("POINT")
# Green space entries
gs_tile <- gs_entries %>%
sf::st_read(wkt_filter = gridBox, quiet = TRUE) %>%
sf::st_cast("POINT")
st_write(gridBox[i,], "C:/Berlin/grid_empty.gpkg")
st_write(cityGrid[i,], "C:/Berlin/grid_empty.gpkg")
build_tile <- tryCatch({build_entries %>%
sf::st_read(wkt_filter = gridBox, quiet = TRUE) %>%
sf::st_cast("POINT")}, error = function(e) message(e) next)
build_tile <- tryCatch({build_entries %>%
sf::st_read(wkt_filter = gridBox, quiet = TRUE) %>%
sf::st_cast("POINT")}, error = function(e) message(e))
# Buildings
build_tile <- tryCatch({build_entries %>%
sf::st_read(wkt_filter = gridBox, quiet = TRUE) %>%
sf::st_cast("POINT")}, error = function(e) message(e))
i
#ncore <- 2
#cl <- makeCluster(ncore, outfile = "")
#registerDoParallel(cl)
# Iterate through city tiles
for (i in 1004:nrow(cityGrid)) { # 13:05
#foreach(i = 1:nrow(cityGrid), .combine = rbind) %dopar% ({
require(dplyr)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-4[A-Za-z].*\\.R|2_.*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
# output directories:
#edge_out <- paste0(output_dir, "edges", i, ".gpkg")
#node_out <- paste0(output_dir, "nodes", i, ".gpkg")
edge_out <- paste0(output_dir, "edges.gpkg")
node_out <- paste0(output_dir, "nodes.gpkg")
#node_missed_out <- paste0(output_dir, "nodes_missed.gpkg")
# User communication
message(paste(i, "of", nrow(cityGrid)))
# Intersect input with grid
gridBox <- cityGrid[i,] %>%
sf::st_geometry() %>%
sf::st_as_text()
# Buildings
build_tile <- tryCatch({build_entries %>%
sf::st_read(wkt_filter = gridBox, quiet = TRUE) %>%
sf::st_cast("POINT")}, error = function(e) message(e))
if (is.null(build_tile)) next
# Green space entries
gs_tile <- gs_entries %>%
sf::st_read(wkt_filter = gridBox, quiet = TRUE) %>%
sf::st_cast("POINT")
# Network (with buffer to avoid errors at edges)
gridBox1 <- cityGrid[i,] %>%
sf::st_buffer(100, nQuadSegs = 1) %>%
sf::st_geometry() %>%
sf::st_as_text()
net_tile <- network %>%
sf::st_read(wkt_filter = gridBox1, quiet = TRUE) %>%
sf::st_cast("LINESTRING")
# Snap buildings and green space entries to network
if (nrow(build_tile) > 0) {
build_snap <- st_snap_points(points = build_tile, lines = net_tile)
} else build_snap <- NULL
if (nrow(gs_tile) > 0) {
gs_snap <- st_snap_points(points = gs_tile, lines = net_tile)
} else gs_snap <- NULL
# Make sure object is not empty
if (is.null(build_snap) & is.null(gs_snap)) next
if (is.null(build_snap)) {nodes <- mutate(gs_snap, population = NA, ID = NA)
} else if (is.null(gs_snap)) {nodes <- mutate(build_snap, city_code = NA,
class = NA, identifier = NA,
area = NA)}  else {
nodes <- dplyr::bind_rows(build_snap, gs_snap) %>%
dplyr::distinct()}
# Blend buildings and green space entries to network
edges <- sf::st_collection_extract(lwgeom::st_split(net_tile, sf::st_buffer(nodes, 1e-5)),
"LINESTRING")
st_geometry(edges) <- edges %>%
st_geometry() %>%
lapply(function(x) round(x, 0)) %>%
st_sfc(crs = 3035)
edges <- distinct(edges)
st_geometry(nodes) <- nodes %>%
st_geometry() %>%
lapply(function(x) round(x, 0)) %>%
st_sfc(crs = 3035)
nodes <- distinct(nodes)
# nodes_net <- edges %>%
#   as_sfnetwork() %>%
#   activate("nodes") %>%
#   st_join(nodes) %>%
#   st_as_sf()
st_write(nodes, node_out, quiet = TRUE, append = TRUE)
st_write(edges, edge_out, quiet = TRUE, append = TRUE)
# if (nrow(build_tile) > 0) {
# filter(nodes, !(ID %in% nodes_net$ID)) %>%
#   st_write(node_missed_out, quiet = TRUE, append = TRUE) }
# tile_blend <-
#   as_sfnetwork(net_tile) %>%
#   st_network_blend(y = nodes)
# # Write results to temp file
# tile_blend %>%
#   activate("edges") %>%
#   st_as_sf() %>%
#   st_write(edge_out, layer = "edges", quiet = TRUE, append = TRUE)
# tile_blend %>%
#   activate("nodes") %>%
#   st_as_sf() %>%
#   st_write(node_out, layer = "nodes", quiet = TRUE, append = TRUE)
# Clean up
# rm(tile_blend, nodes, net_tile, gs_tile, gs_snap,
#    build_tile, build_snap)
# gc()
#return(i)
}

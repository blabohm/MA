outDir <- "C:/Berlin/buildings.gpkg"
buildingPrep(osm_directory = osmDir,
ua_directory = uaDir,
city_code = cityCode,
city_boundaries = cityBound,
out_dir = outDir)
buildingPrep(osm_directory = osmDir,
ua_directory = uaDir,
city_code = cityCode,
city_boundaries = cityBound,
out_dir = outDir)
?st_cast
be_dir <- "C:/Berlin/buildings.gpkg"
bEntries <- st_read(be_dir, quiet = TRUE)
################################################################################
# OVERVIEW:
# CONVERT TO BUILDING CENTROID
# READ OSM NETWORK
# OUTPUT TO TEMP
################################################################################
net_dir <- "C:/Berlin/network_clean1.gpkg"
gs_dir <- "C:/Berlin/green_space_entries.gpkg"
be_dir <- "C:/Berlin/buildings.gpkg"
# LOAD PACKAGES AND FUNCTIONS
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-4[A-Za-z].*\\.R|2_.*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
# READ OSM NETWORK
OSMnetwork <- st_read(network_dir, quiet = TRUE)
gsEntries <- st_read(green_space_dir, quiet = TRUE)
bEntries <- build_entry_dir %>%
st_read(quiet = TRUE) %>%
st_point_on_surface()
network_dir = netDir
################################################################################
# OVERVIEW:
# CONVERT TO BUILDING CENTROID
# READ OSM NETWORK
# OUTPUT TO TEMP
################################################################################
netDir <- "C:/Berlin/network_clean1.gpkg"
gsDir <- "C:/Berlin/green_space_entries.gpkg"
beDir <- "C:/Berlin/buildings.gpkg"
outDir <- "C:/Berlin/popTilesSnapped/"
################################################################################
# OVERVIEW:
# CONVERT TO BUILDING CENTROID
# READ OSM NETWORK
# OUTPUT TO TEMP
################################################################################
netDir <- "C:/Berlin/network_clean1.gpkg"
gsDir <- "C:/Berlin/green_space_entries.gpkg"
beDir <- "C:/Berlin/buildings.gpkg"
outDir <- "C:/Berlin/popTilesSnapped/"
network_dir = netDir
green_space_dir = gsDir
build_entry_dir = beDir
output_dir = outDir
# LOAD PACKAGES AND FUNCTIONS
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
getwd() %>%
paste0("/tool/Module 2 - data preparation/functions/") %>%
list.files(pattern = "2-4[A-Za-z].*\\.R|2_.*\\.R", full.names = TRUE) %>%
for (file in .) source(file)
if (!dir.exists(tmpDir)) dir.create(tmpDir)
if (!dir.exists(output_dir)) dir.create(output_dir)
# READ OSM NETWORK
OSMnetwork <- st_read(network_dir, quiet = TRUE)
gsEntries <- st_read(green_space_dir, quiet = TRUE)
bEntries <- build_entry_dir %>%
st_read(quiet = TRUE) %>%
st_point_on_surface()
cityBound <- "E:/citiesEurope/Cities.shp"
city_code <- "DE001"
city_boundary <- boundaryLoader(city_boundaries = city_boundaries,
city_code = city_code, code_string = "URAU_CO")
cityBound <- "E:/citiesEurope/Cities.shp"
city_boundaries = cityBound
city_boundary <- boundaryLoader(city_boundaries = city_boundaries,
city_code = city_code, code_string = "URAU_CO")
# SNAP AND BLEND BUILDING AND PARK ENTRIES TO NETWORK
snapAndBlend(city_boundary = city_boundary, build_entries = bEntries,
gs_entries = gsEntries, network = OSMnetwork, out_dir = outDir)
snapAndBlend <- function(city_boundary, build_entries, gs_entries, network,
cellsize = 3000, out_dir, crs = 3035)
{
# Load required packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
require(sfnetworks, quietly = TRUE)
# require(igraph)
# require(tidygraph)
# Tile boundaries
cityGrid <- city_boundary %>%
st_transform(crs) %>%
st_buffer(1000) %>%
st_make_grid(cellsize = cellsize) %>%
st_as_sf() %>%
st_filter(city_boundary, .pred = st_intersects)
# Iterate through city tiles
for (i in 1:nrow(cityGrid)) {
# User communication
message(paste(i, "of", nrow(cityGrid)))
# Intersect input with grid
# Buildings
build_tile <-
build_entries %>%
st_transform(crs) %>%
st_intersection(cityGrid$x[i]) %>%
st_cast("POINT")
# Green space entries
gs_tile <-
gs_entries %>%
st_transform(crs) %>%
st_intersection(cityGrid$x[i]) %>%
st_cast("POINT")
# Network
gb <- st_buffer(cityGrid$x[i], 100)
net_tile <-
network %>%
st_transform(crs) %>%
st_filter(gb, .predicate = st_intersects) %>%
st_cast("LINESTRING")
# Snap buildings and green space entries to network
if (nrow(build_tile) > 0) {
build_snap <- st_snap_points(points = build_tile, lines = net_tile)
} else build_snap <- NULL
if (nrow(gs_tile) > 0) {
gs_snap <- st_snap_points(points = gs_tile, lines = net_tile)
} else gs_snap <- NULL
# Make sure object is not empty
if (is.null(build_snap)) {nodes <- gs_snap
} else if (is.null(gs_snap)) {nodes <- build_snap}  else {
nodes <- bind_rows(build_snap, gs_snap)}
# Blend buildings and green space entries to network
tile_blend <-
as_sfnetwork(net_tile) %>%
st_network_blend(y = nodes)
# Write results to temp file
tile_blend %>%
activate("edges") %>%
st_as_sf() %>%
st_write(edge_out, layer = "edges", quiet = TRUE, append = TRUE)
tile_blend %>%
activate("nodes") %>%
st_as_sf() %>%
st_write(node_out, layer = "nodes", quiet = TRUE, append = TRUE)
# Clean up
rm(tile_blend, nodes, net_tile, gs_tile, gs_snap,
build_tile, build_snap)
gc()
}
}
outDir <- "C:/Berlin/net_blend/"
output_dir = outDir
if (!dir.exists(output_dir)) dir.create(output_dir)
output_dir
snapAndBlend <- function(city_boundary, build_entries, gs_entries, network,
cellsize = 3000, output_dir, crs = 3035)
{
# Load required packages
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
require(sfnetworks, quietly = TRUE)
# require(igraph)
# require(tidygraph)
# output directories:
edge_out <- paste0(output_dir, "edges.gpkg")
node_out <- paste0(output_dir, "nodes.gpkg")
# Tile boundaries
cityGrid <- city_boundary %>%
st_transform(crs) %>%
st_buffer(1000) %>%
st_make_grid(cellsize = cellsize) %>%
st_as_sf() %>%
st_filter(city_boundary, .pred = st_intersects)
# Iterate through city tiles
for (i in 1:nrow(cityGrid)) {
# User communication
message(paste(i, "of", nrow(cityGrid)))
# Intersect input with grid
# Buildings
build_tile <-
build_entries %>%
st_transform(crs) %>%
st_intersection(cityGrid$x[i]) %>%
st_cast("POINT")
# Green space entries
gs_tile <-
gs_entries %>%
st_transform(crs) %>%
st_intersection(cityGrid$x[i]) %>%
st_cast("POINT")
# Network
gb <- st_buffer(cityGrid$x[i], 100)
net_tile <-
network %>%
st_transform(crs) %>%
st_filter(gb, .predicate = st_intersects) %>%
st_cast("LINESTRING")
# Snap buildings and green space entries to network
if (nrow(build_tile) > 0) {
build_snap <- st_snap_points(points = build_tile, lines = net_tile)
} else build_snap <- NULL
if (nrow(gs_tile) > 0) {
gs_snap <- st_snap_points(points = gs_tile, lines = net_tile)
} else gs_snap <- NULL
# Make sure object is not empty
if (is.null(build_snap)) {nodes <- gs_snap
} else if (is.null(gs_snap)) {nodes <- build_snap}  else {
nodes <- bind_rows(build_snap, gs_snap)}
# Blend buildings and green space entries to network
tile_blend <-
as_sfnetwork(net_tile) %>%
st_network_blend(y = nodes)
# Write results to temp file
tile_blend %>%
activate("edges") %>%
st_as_sf() %>%
st_write(edge_out, layer = "edges", quiet = TRUE, append = TRUE)
tile_blend %>%
activate("nodes") %>%
st_as_sf() %>%
st_write(node_out, layer = "nodes", quiet = TRUE, append = TRUE)
# Clean up
rm(tile_blend, nodes, net_tile, gs_tile, gs_snap,
build_tile, build_snap)
gc()
}
}
# SNAP AND BLEND BUILDING AND PARK ENTRIES TO NETWORK
snapAndBlend(city_boundary = city_boundary, build_entries = bEntries,
gs_entries = gsEntries, network = OSMnetwork, out_dir = outDir)
# SNAP AND BLEND BUILDING AND PARK ENTRIES TO NETWORK
snapAndBlend(city_boundary = city_boundary, build_entries = bEntries,
gs_entries = gsEntries, network = OSMnetwork,
output_dir = outDir)
out == "file"
out = "file"
out == "file"
output_dir <- readline(prompt = "Please enter output directory.")
readline(prompt = "Please enter output directory. \n")
is.null(output_dir) & out == "file"
output_dir <- NULL
is.null(output_dir) & out == "file"
library(dplyr)
getwd() %>%
paste0("/tool/Module 3 - index building/functions/") %>%
list.files(pattern = "3-1[A-Za-z].*\\.R", full.names = TRUE)
# DATA DIRECTORIES
drive <- "D:/"
nodeDir <- paste0(drive, "Berlin/nodes.gpkg")
edgeDir <- paste0(drive, "Berlin/edges.gpkg")
# LOAD PACKAGES AND FUNCTIONS
require(dplyr, quietly = TRUE)
require(sf, quietly = TRUE)
node_directory = nodeDir
edge_directory = edgeDir
# LOAD NODES
nodes <- st_read(node_directory, quiet = TRUE)
nodes1 <- distinct(nodes1)
nodes1 <- distinct(nodes)
rm(nodes)
st_write(nodes1, nodeDir)
st_write(nodes1, nodeDir)
# FILTER FOR GREEN SPACE ENTRIES
gs_entries <- nodes %>%
filter(!is.na(area))
nodes <- nods1
nodes <- nodes1
rm(nodes1)
# FILTER FOR GREEN SPACE ENTRIES
gs_entries <- nodes %>%
filter(!is.na(area))
View(gs_entries)
glimpse(gs_entries)
# LOAD NODES
gs_entries <- node_directory %>%
st_read(quiet = TRUE) %>%
# FILTER FOR GREEN SPACE ENTRIES
filter(!is.na(area)) %>%
select(-C(ID, population, city_code))
# LOAD NODES
gs_entries <- node_directory %>%
st_read(quiet = TRUE) %>%
# FILTER FOR GREEN SPACE ENTRIES
filter(!is.na(area)) %>%
select(-C("ID", "population", "city_code"))
# LOAD NODES
gs_entries <- node_directory %>%
st_read(quiet = TRUE) %>%
# FILTER FOR GREEN SPACE ENTRIES
filter(!is.na(area)) %>%
select(identifier, area)
# LOAD NODES
gs_IDs <- node_directory %>%
st_read(quiet = TRUE) %>%
# FILTER FOR GREEN SPACE ENTRIES
filter(!is.na(area)) %>%
pull(identifier)
# LOAD NODES
gs_IDs <- node_directory %>%
st_read(quiet = TRUE) %>%
# FILTER FOR GREEN SPACE ENTRIES
filter(!is.na(area)) %>%
pull(identifier) %>%
unique()
test <- st_read(node_directory, query = "SELECT identifier FROM nodes WHERE identifier is not na")
test <- st_read(node_directory, query = "SELECT identifier FROM nodes WHERE identifier is not null")
test
test <- st_read(node_directory,
query =
"SELECT identifier
FROM nodes
WHERE identifier is not null
DropGeometryColumn")
test <- st_read(node_directory,
query =
"SELECT identifier
FROM nodes
WHERE identifier is not null")
test <- st_read(node_directory,
query =
"SELECT identifier
FROM nodes
WHERE identifier is not null
DropGeometryColumn
SELECT identifier
FROM nodes")
test <- st_read(node_directory,
query =
"SELECT identifier
FROM nodes
WHERE identifier is not null
SELECT identifier
FROM nodes
DropGeometryColumn")
# LOAD NODES, FILTER FOR GREEN SPACE ENTRIES AND GET IDENTIFIER VALUES
gs_IDs <- node_directory %>%
st_read(node_directory,
query = "SELECT identifier FROM nodes WHERE identifier is not null")
# LOAD NODES, FILTER FOR GREEN SPACE ENTRIES AND GET IDENTIFIER VALUES
gs_IDs <- node_directory %>%
st_read(node_directory,
query = "SELECT identifier FROM nodes WHERE identifier is not null") %>%
pull(identifier) %>%
unique()
# LOAD NODES, FILTER FOR GREEN SPACE ENTRIES AND GET IDENTIFIER VALUES
gs_IDs <- node_directory %>%
st_read(query = "SELECT identifier FROM nodes WHERE identifier is not null") %>%
pull(identifier) %>%
unique()
rm(gs_entries)
rm(gs_IDs)
# LOAD NODES, FILTER FOR GREEN SPACE ENTRIES AND GET IDENTIFIER VALUES
gs_IDs <- node_directory %>%
st_read(query = "SELECT identifier FROM nodes WHERE identifier is not null") %>%
pull(identifier) %>%
unique()
rm(nodes)
rm(test)
gc()
################################################################################
# 1. FUNCTION DESCRIPTION (SHORT)
# REQUIRED SETTINGS:
# setting_name: Setting description
# OPTIONAL SETTINGS:
# setting_name: Setting description - DEFAULT values
################################################################################
system.time({st_read(node_directory, quiet = TRUE) %>%
filter(!is.na(identifier)) %>%
pull(identifier) %>%
unique()})
system.time({
st_read(node_directory,
query =
"SELECT identifier FROM nodes WHERE identifier is not null") %>%
pull(identifier) %>%
unique()
})
system.time({
st_read(node_directory,
query =
"SELECT identifier FROM nodes WHERE identifier is not null",
quiet = TRUE) %>%
pull(identifier) %>%
unique()
})
################################################################################
# 1. FUNCTION DESCRIPTION (SHORT)
# REQUIRED SETTINGS:
# setting_name: Setting description
# OPTIONAL SETTINGS:
# setting_name: Setting description - DEFAULT values
################################################################################
system.time({st_read(node_directory, quiet = TRUE) %>%
filter(!is.na(identifier)) %>%
pull(identifier) %>%
unique()})
system.time({
st_read(node_directory,
query =
"SELECT identifier FROM nodes WHERE identifier is not null",
quiet = TRUE) %>%
pull(identifier) %>%
unique()
})
i <- gs_IDs[1]
i
# GRENN SPACE ENTRIES
gs_query <- paste("SELECT identifier FROM nodes WHERE identifier =",
i)
gs_query
# GRENN SPACE ENTRIES
gs_query <- paste("SELECT identifier FROM nodes WHERE identifier = \'",
i, "\'")
gs_query
# GRENN SPACE ENTRIES
gs_query <- paste0("SELECT identifier FROM nodes WHERE identifier = \'",
i, "\'")
gs_query
gs_entries <- node_directory %>%
st_read(query = gs_query)
gs_entries <- node_directory %>%
st_read(query = gs_query, quiet = TRUE)
gs_entries
# GRENN SPACE ENTRIES
gs_query <- paste0("SELECT * FROM nodes WHERE identifier = \'",
i, "\'")
gs_entries <- node_directory %>%
st_read(query = gs_query, quiet = TRUE)
gs_entries
# GRENN SPACE ENTRIES
gs_query <- paste0("SELECT identifier, area, geom FROM nodes WHERE identifier = \'",
i, "\'")
gs_entries <- node_directory %>%
st_read(query = gs_query, quiet = TRUE)
gs_entries
# GRENN SPACE ENTRIES
gs_query <- paste0("SELECT identifier, area, geom
FROM nodes
WHERE identifier = \'",
i, "\'")
gs_entries <- node_directory %>%
st_read(query = gs_query, quiet = TRUE)
gs_entries
d <- 500
gs_filter <- gs_entries %>%
st_buffer(d) %>%
st_geometry() %>%
st_as_text()
gs_filter
network <- edge_directory %>%
st_read(wkt_filter = gs_filter, quiet = TRUE)
plot(network)
plot(network$geom)
plot(gs_entries$geom, add = TRUE)
# convert network to service area
nbh <- st_network_multijoin(pe, d, network)
st_network_multijoin <- function(park_entries, distance, network) {
# sophisticated way of converting to neighborhood
b <- st_coordinates(park_entries)
xmin <- b[which.min(b[,1]),] %>% st_point()
xmax <- b[which.max(b[,1]),] %>% st_point()
ymin <- b[which.min(b[,2]),] %>% st_point()
ymax <- b[which.min(b[,2]),] %>% st_point()
p <- st_sfc(xmin, xmax, ymin, ymax, crs = 3035)
bn_clip <- p %>%
st_geometry() %>%
st_combine() %>%
st_cast("POLYGON") %>%
st_buffer(distance) %>%
st_filter(activate(network, "nodes"), ., .pred = st_intersects)
nbh1 <- convert(bn_clip, to_spatial_neighborhood, p[1], distance)
nbh2 <- convert(bn_clip, to_spatial_neighborhood, p[2], distance)
nbh3 <- convert(bn_clip, to_spatial_neighborhood, p[3], distance)
nbh4 <- convert(bn_clip, to_spatial_neighborhood, p[4], distance)
nbh5 <- st_network_join_working(nbh1, nbh2)
nbh6 <- st_network_join_working(nbh3, nbh4)
nbh <- st_network_join_working(nbh5, nbh6) %>%
convert(to_undirected) %>%
filter(group_components() == 1) %>%
distinct()
rm(nbh1, nbh2, nbh3, nbh4, nbh5, nbh6)
return(nbh)}
st_network_join_working <- function(x, y) {
st_network_join(activate(x, "nodes"),
activate(y, "nodes"),
suffix = c(".x", ".y")) %>%
mutate(identifier = coalesce(identifier.x, identifier.y),
code_2018 = coalesce(code_2018.x, code_2018.y),
population = coalesce(population.x, population.y),
area = coalesce(area.x, area.y),
detour_index = coalesce(detour_index.x, detour_index.y),
di_count = coalesce(di_count.x, di_count.y),
node_id = coalesce(node_id.x, node_id.y),
.tidygraph_node_index = coalesce(.tidygraph_node_index.x,
.tidygraph_node_index.y)) %>%
select(identifier, code_2018, population, area, node_id, detour_index,
di_count, .tidygraph_node_index)}
# convert network to service area
nbh <- st_network_multijoin(pe, d, network)
# convert network to service area
nbh <- st_network_multijoin(gs_entries, d, network)
x <- 1
x
x = 1
x
